Интерфейсы в Golang

	"Что такое интерфейсы в go?"
		Интерфейс можно рассматривать, как некое соглашение (контракт), 
		что тот или иной объект будет реализовывать указанное в интерфейсе поведение.
		Переводя на более человеческий язык, интерфейс - это структура, в которой описаны методы, 
		которые должны быть реализованы для других структур, которые будут удовлетворять этому интерфейсу. 
		Удовлетворение интерфейсу поддерживается на неявном уровне. 
		То есть для объекта достаточно описать реализацию методов интерфейса. 
		И объект, без дополнительных объявлений в кодовой базе, начинает удовлетворять этому интерфейсу.
	
	"Дайте пример реализации интерфейсов."
		type Squarer interface {
			GetSquare() int
		}

		type Foursquare struct {
			a int
		}

		func (obj Foursquare) GetSquare() int {
			return obj.a * obj.a
		}

		type Triangle struct {
			a int // катет
			b int // катет
			c int // гипотенуза
		}

		func (obj Triangle) GetSquare() int {
			return obj.a * obj.b / 2
		}

		func sumSquare(s []Squarer) int {
			square := 0
		
			for i := range s {
				square += s[i].GetSquare()
			}

			return square
		}

		func main() {

			figures := []Squarer{Foursquare{a: 3}, Foursquare{a: 2}, Triangle{a: 2, b: 3}}

			fmt.Println(sumSquare(figures))
		}

	"Что такое пустой интерфейс?"
		Исходя из определения интерфейса, пустой интерфейс - это интерфейс, для реализации которого не нужно описывать ни одного метода. 
		Таким образом, пустому интерфейсу соответствует абсолютно любой тип.

	"Что такое nil интерфейс?"
		Интерфейс реализован в go, как структура, которая содержит в себе ссылку на само значение и ссылку на структуру itab.
		itab предоставляет служебную информацию об интерфейсе и базовом типе.
		Когда интерфейс nil значит, что интерфейс не ссылается на какое либо значение, 
		но при этом содержит в себе служебную информацию поля itab. 
		По этой причине булево сравнение nil с интерфейсом всегда ложное.

	"Как преобразовать интерфейс к другому типу?"
		Интерфейс можно преобразовать в базовый тип значения (скастить). 
		Для этого используется синтаксис, возвращающий две переменные, одна из которых булевая.
		В случае, если не удалось скастить интерфейс, булевая переменная будет ложной, 
		а переменная базового типа, к которому приводим интерфейс будет равна дефолтному значению этого типа.

	"Как определить тип интерфейса?"
		С помощью инструкции switch case можно определить тип интерфейса, указав возможные варианты базового типа его значения.

		func do(i interface{}) {
			switch v := i.(type) {
			case int:
				fmt.Printf("Twice %v is %v\n", v, v*2)
			case string:
				fmt.Printf("%q is %v bytes long\n", v, len(v))
			default:
				fmt.Printf("I don't know about type %T!\n", v)
				}
		}