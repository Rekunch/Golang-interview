"Термины ООП" 

	класс - тип, описывающий устройство объектов. Описание сущности, у которой есть определенный набор свойств и методов.
	
	инкапсуляция - сокрытие деталей реализации той или иной подсистемы программы от других ее подсистем.

	наследование - возможность одному классу выступать в качестве наследника для другого, перенимая его свойства и методы.
	Наследник может не только использоваться методы и свойства родительского класса, но и переопределять их, а также добавлять новые.

	полиморфизм - способность одинаковый конструкция обозначать различные действия в зависимости от типов переменных.

	перегрузка операторов - возможность создавать функции с одним именем, но с разными параметрами (в с++) : 
		void print(int n) {print(n)}
		void print(char s) {print(n)}

"Как реализовано ООП в go?"

	"наследование" 
		Как такового наследования в go нет, но при этом у нас есть структуры - это специальные типы, 
		в которые мы можем включать другие типы, в том числе такие же структуры.
		При этом методы дочерних структур родительская структура также будет наследовать.
		Отсюда интервьюер может задать вопрос: "Что будет, если и в родительской и дочерней структуре есть реализация методов с одинаковым названием?" 
		Ответ на этот вопрос такой: "Реализация родительского метода будет переписана реализацией дочернего метода".

		"пример" : 
			type Parent struct{}

			func (c *Parent) Print() {
				fmt.Println("parent")
			}

			type Child struct {
				Parent
			}

			func (p *Child) Print() {
				fmt.Println("child")
			}

			func main() {
				var x Child

				x.Print()
			}

			Output : child

	"инкапсуляция"
		Инкапсуляция в go - это возможность задавать переменным, функциям и методам первую букву названия в верхнем или нижнем регистре. 
        Соответственно нижний регистр будет значить, что переменная, функция или метод доступна только в рамках пакета.
        Тогда как верхний регистр даст доступ к переменной, функции или методу за рамками пакета.
	
	"полиморфизм"
		Полиморфизм в go реализован с помощью интерфейсов.
		Основная идея заключается в том, что мы можем объявить интерфейсы (контракты на определённое поведение) для наших типов. 
		При этом, для типов мы должны реализовать методы, удовлетворяющие этим интерфейсам. 
		Таким образом, мы сможем работать со всем набором типов, у которых реализовали интерфейсы, как с единым интерфейсным типом.



"switch-case"

	"В go есть оператор switch case, можно ли выполнить несколько условий в одном объявленном операторе?"
		Такое возможно благодаря ключевому слову fallthrough. 
		Оно заставляет выполнять код в следующей объявленной булевой секции, вне зависимости подходит ли булевое условие case этой секции.